Starting weekly assessment for Pablo, Week5

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 94.04 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week6, Week1, Week7, Assessment, Week8, Week5, Week2, Week9, Week4, .git, Week3, mini_project

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
*.log
__pycache__/

questions.txt
.DS_Store

########Git ignore for r##########

# History files
.Rhistory
.Rapp.history

# Session Data files
.RData

# User-specific files
.Ruserdata

# Example code in package build process
*-Ex.R

# Output files from R CMD build
/*.tar.gz

# Output files from R CMD check
/*.Rcheck/

# RStudio files
.Rproj.user/

# produced vignettes
vignettes/*.html
vignettes/*.pdf

# OAuth2 token, see https://github.com/hadley/httr/releases/tag/v0.3
.httr-oauth

# knitr and R markdown default cache directories
*_cache/
/cache/

# Temporary files created by R markdown
*.utf8.md
*.knit.md
**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# Computational Methods in Ecology and Evolution (CMEE) MSc


## Week 1

### Unix
1. Practicals (`UnixPrac1.txt`)
### Shell scripting 
1. Your first shell script (`boilerplate.sh`)
2. Variables in shell scripts (`tabtocsv.sh`, `variables.sh`, `MyExampleScript.sh`, `CountLines.sh`, `ConcatenateTwoFiles.sh`, `tiff2png.sh`, `csvtospace.sh`)
### Version control with Git
### Scientific documents with LaTeX 
1. A first LaTeX example (`FirstExample.tex`, `FirstBiblio.bib`, `CompileLatex.sh`)

## Week 2 

### Biological computing in Python I
1. Writting python code (`basic_io1.py`, `basic_io2.py`, `basic_io3.py`)
2. Running python scripts (`basic_csv.py`)
3. Control flow tools (`cfexercises1.py`, `cfexercises2.py`, `control_flow.py`, `loops.py`)
4. Comprehensions (`oaks.py`)
5. Variable Scope (`scope.py`)
6. Writing Python programs (`boilerplate.py`, `using_name.py`, `sysargv.py`)
8. Errors in your Python code (`control_flow.py`, `debugme.py`)
7. Practicals (`lc1.py`, `lc2.py`, `dictionary.py`, `tuple.py`, `cfexercises1.py`, `cfexercises2.py`, `align_seqs.py`, `align_fasta.py`, `align_better.py`, `oaks_debugme.py`)

## Week 3
### Biological Computing in R
1. Writing R code (`basic_io.R`)
2. Control flow tools (`control_flow.R`, `break.R`)
3. Writing R functions (`boilerplate.r`)
4. Vectorization (`Vectorize1.R`, `Vectorize2.R`, `preallocate.R`, `sample.R`)
5. Errors and Debugging (`browse.R`)
6. Practicals ('TreeHight `Ricker.R`, `Vectorize1.py`, `Vectorize2.py`, `run_Vectorize.sh`, `TAutoCorr.R`, `TreeHeight.R`, `get_TreeHeight.R`, `run_get_TreeHeight.sh`, `get_TreeHeight.py`)
### Data management, exploration and visualization
1. Data Wrangling (`DataWrang.R`)
2. Practicals (`PP_Lattice.R`, `Girko.R`, `MyBars.R`, `plotLin.R`,`PP_Regress.R`, `PP_Regress_loc.R` )
## Week 4
### Descriptive statistics
2. t-test
3. ANOVA
4. Correlations
5. Linear models
6. Hypothesis testing
## Week 5
### Spatial Analyses and Geographic Information Systmens (GIS)
## Week 6
### Genomics and Bioinformatics
## Week 7
### Biological Computing in Python II
1. Profiling in Python (`profileme.py`, `profileme2.py`, `timetime.py`)
2. Networks in Python (`DrawFW.py`)
3. Practicals (`LV1.py`, `LV2.py`, `LV3.py`, `LV4.py`, `Nets.R`, `regex.py`, `blackbirds.py`, `TestR.R`, `TestR.py`, `using_os.py`, `run_fmr_R.py`, `fmr.R` )
## Week 8
### High Performance Computing (HPC)
## Week 9
### Biological Data Structures and C
## mini_project
    


*Pablo Lechon (plechon@ucm.es)*
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 9 weekly directories: Week1, Week2, Week3, Week4, Week5, Week6, Week7, Week8, Week9

The Week5 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK5...

Found the following directories: Code, Data

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# Week 5 README

This folder contains three subfolders: Data, were we store the data used in our code; Code, were we have the writen code; and Sandbox, were we store everything that is not Data or Code.

## Spatial Analyses and Geographic Information Systems (GIS)
1. Familiarity with a range of GIS data types 
1. Confidence in obtaining an handling GIS data 
2. Practical experience in creating maps
**********************************************************************

Results directory missing!

Creating Results directory...

Found 3 code files: nlls.R, GIS.R, research_taste.R

======================================================================
Testing script/code files...

======================================================================
Inspecting script file nlls.R...

File contents are:
**********************************************************************
setwd('/Users/pablolechon/Desktop/Imperial/CMEECourseWork/Week5')
rm(list = ls())
library(repr)
graphics.off()
options(repr.plot.width = 4, 
        repr.plot.height = 4)
install.packages('minipack.lm')
require('minipack.lm')
**********************************************************************

Testing nlls.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Error in setwd("/Users/pablolechon/Desktop/Imperial/CMEECourseWork/Week5") : 
  cannot change working directory
Execution halted

======================================================================
Inspecting script file GIS.R...

File contents are:
**********************************************************************
setwd('Desktop/Imperial/CMEECourseWork/Week5/Code/')

library(raster)
library(sf)
library(viridis)
library(units)
library(rgeos)
library(proj4)
library(lwgeom)


####3.1 Making vectors from coordinates#####

#create a population density map for the British Isles
pop_dens <- data.frame(n_km2 = c(260, 67,151, 4500, 133), 
                       country = c('England','Scotland', 'Wales', 
                                   'London', 'Northern Ireland'))
print(pop_dens)

#In order to create vector data, we need to provide a set 
#of coordinates for the points. For different kinds of 
#coordinates are provided in different ways. Here, we are 
#just using very simple polygons to show the countries.
scotland <- rbind(c(-5, 58.6), c(-3, 58.6), c(-4, 57.6), 
                  c(-1.5, 57.6), c(-2, 55.8), c(-3, 55), 
                  c(-5, 55), c(-6, 56), c(-5, 58.6))
england <- rbind(c(-2,55.8),c(0.5, 52.8), c(1.6, 52.8), 
                 c(0.7, 50.7), c(-5.7,50), c(-2.7, 51.5), 
                 c(-3, 53.4),c(-3, 55), c(-2,55.8))
wales <- rbind(c(-2.5, 51.3), c(-5.3,51.8), c(-4.5, 53.4),
               c(-2.8, 53.4),  c(-2.5, 51.3))
ireland <- rbind(c(-10,51.5), c(-10, 54.2), c(-7.5, 55.3),
                 c(-5.9, 55.3), c(-5.9, 52.2), c(-10,51.5))
#Convert these coordinates into feature geometries
#these are simple coordinate sets with no projection 
#information
scotland <- st_polygon(list(scotland))
england <- st_polygon(list(england))
wales <- st_polygon(list(wales))
ireland <- st_polygon(list(ireland))

#Combine geometries into a simple feature column
uk_eire <- st_sfc(wales, england, scotland, ireland, crs=4326)
plot(uk_eire, asp=1)

uk_eire_capitals <- data.frame(long= c(-0.1, -3.2, -3.2, -6.0, -6.25),
                               lat=c(51.5, 51.5, 55.8, 54.6, 53.30),
                               name=c('London', 'Cardiff', 'Edinburgh', 
                                      'Belfast', 'Dublin'))

uk_eire_capitals <- st_as_sf(uk_eire_capitals, coords=c('long','lat'), 
                             crs=4326)


####3.2 Vector geometry operations#####

st_pauls <- st_point(x=c(-0.098056, 51.513611))
london <- st_buffer(st_pauls, 0.25)
england_no_london <- st_difference(england, london)

# Count the points and show the number of rings within the polygon features
lengths(scotland)
lengths(england_no_london)

#We can use the same operation to tidy up Wales: in this 
#case we want the bits of Wales that are different from 
#England.
wales <- st_difference(wales, england)

#Now we will use the intersection operation to separate 
#Northern Ireland from the island of Ireland. First we 
#create a rough polygon that includes Northern Ireland 
#and sticks out into the sea; then we find the 
#intersection and difference of that with the Ireland 
#polygon to get Northern Ireland and Eire.

# A rough polygon that includes Northern Ireland and surrounding sea.
# - not the alternative way of providing the coordinates
ni_area <- st_polygon(list(cbind(x=c(-8.1, -6, -5, -6, 
                                     -8.1), 
                                 y=c(54.4, 56, 55, 54,
                                     54.4))))
northern_ireland <- st_intersection(ireland, ni_area)
eire <- st_difference(ireland, ni_area)
# Combine the final geometries
uk_eire <- st_sfc(wales, england_no_london, scotland, 
                  london, northern_ireland, eire, 
                  crs=4326)


####3.3 Features and geometries####

#Remove the republic! (the sixth element)
uk_country <- st_union(uk_eire[-6])

# Plot them
par(mfrow=c(1, 2), mar=c(3,3,1,1))
plot(uk_eire, asp=1, col=rainbow(6))
plot(st_geometry(uk_eire_capitals), add=TRUE)
plot(uk_country, asp=1, col='lightblue')


####3.4 Vector data and attributes####

uk_eire <- st_sf(name=c('Wales', 'England','Scotland', 
                        'London','Northern Ireland', 
                        'Eire'),
                 geometry=uk_eire)

plot(uk_eire, asp=1)

#Since an sf object is an extended data frame, we can 
#add attributes by adding fields directly:
uk_eire$capital <- c('London', 'Edinburgh',
                     'Cardiff', NA, 'Belfast','Dublin')

#We can also use the merge command to match data in. 
#Note that we need to use by.x and by.y to say which 
#columns we expect to match. We also use all.x=TRUE, 
#otherwise Eire will be dropped from the spatial data 
#because it has no population density estimate in the 
#data frame. If we look at the result, we get some 
#header information about the spatial data and then 
#something that looks very like a data frame printout, 
#with the extra geometry column.
uk_eire <- merge(x = uk_eire,y =  pop_dens, 
                 by.x='name', by.y='country', 
                 all.x=TRUE)
print(uk_eire)


####3.5 Spatial attributes####

#One common thing that people want to know are spatial 
#attributes of geometries and there are a range of 
#commands to find these things out. 
#One thing we might want are the centroids of features.
uk_eire_centroids <- st_centroid(uk_eire)
st_coordinates(uk_eire_centroids)
#The sf package warns us here that this isn’t a sensible 
#thing to do. There isn’t a good way to calculate a true 
#centroid for geographic coordinates

#length of a feature and its area. Note that here sf is 
#able to do something clever behind the scenes. 
#Rather than give us answers in units of degrees, 
#it notes that we have a goegraphic coordinate system 
#and instead uses internal transformations to give us 
#back accurate distances and areas using metres. Under 
#the hood, it is using calculations on the surface of a 
#sphere, so called great circle distances.
uk_eire$area <- st_area(uk_eire)
# The length of a polygon is the perimeter length 
#- note that this includes the length of internal holes.
uk_eire$length <- st_length(uk_eire)
# Look at the result
print(uk_eire)
# You can change units in a neat way
uk_eire$area <- set_units(uk_eire$area, 'km^2')
uk_eire$length <- set_units(uk_eire$length, 'km')
print(uk_eire)

#A final useful example is the distance between objects: 
#sf gives us the closest distance between geometries, 
#which might be zero if two features are touching.
st_distance(uk_eire)
st_distance(uk_eire_centroids)
#If you plot an sf object, the default is to plot a map 
#for every attribute. You can pick a column to show 
#using square brackets. So, now we can show our map of 
#population density:
plot(uk_eire['n_km2'], asp=1) 
#on that note (I am gonna leave) try: plot(uk_eire, asp=1)
#The scale on that plot isn’t very helpful. Look at 
#?plot.sf and see if you can get a log scale on the 
#right.
plot(uk_eire['n_km2'], asp=1, logz=TRUE)


####3.7 Reprojecting vector data####

#We will reproject our UK and Eire map onto a good 
#choice of local projected coordinate system: the 
#British National Grid. We can also use a bad 
#choice: the UTM 50N projection, which is 
#appropriate for Borneo. It does not end well if 
#we use it to project the UK and Eire.
# British National Grid (EPSG:27700)
uk_eire_BNG <- st_transform(uk_eire, 27700)
# The bounding box of the data shows the change in units
st_bbox(uk_eire)
##  xmin  ymin  xmax  ymax 
## -10.0  50.0   1.6  58.6

st_bbox(uk_eire_BNG)
##       xmin       ymin       xmax       ymax 
## -154811.97   17655.72  642773.71  971900.65

# UTM50N (EPSG:32650)
uk_eire_UTM50N <- st_transform(uk_eire, 32650)
# Plot the results
par(mfrow=c(1, 3), mar=c(3,3,1,1))
plot(st_geometry(uk_eire), asp=1, axes=TRUE, main='WGS 84')
plot(st_geometry(uk_eire_BNG), axes=TRUE, main='OSGB 1936 / BNG')
plot(st_geometry(uk_eire_UTM50N), axes=TRUE, main='UTM 50N')


###Degrees are not constant###

#The units of geographic coordinate systems are 
#angles of latitide and longitude. These are not a 
#constant unit of distance and as lines of 
#longitude converge towards to pole, the physical 
#length of a degree decreases. This is why our 
#0.25° buffered point for London is stupid and why 
#it is distorted in the projected data.

# Set up some points separated by 1 degree latitude 
#and longitude from St. Pauls
st_pauls <- st_sfc(st_pauls, crs=4326)
# near Goring
one_deg_west_pt <- st_sfc(st_pauls - c(1, 0), 
                          crs=4326) 
# near Peterborough
one_deg_north_pt <-  st_sfc(st_pauls + c(0, 1), 
                            crs=4326) 
# Calculate the distance between St Pauls and each 
#point
st_distance(st_pauls, one_deg_west_pt)
st_distance(st_pauls, one_deg_north_pt)

#Note that the great circle distance between London 
#and Goring - which accounts for the curvature of 
#the earth - is roughly 17 metres longer than the 
#distance between the same coordinates projected 
#onto the British National Grid.
st_distance(st_transform(st_pauls, 27700), 
            st_transform(one_deg_west_pt, 27700))

#Our feature for London would be far better if it 
#used a constant 25km buffer around St. Pauls, 
#rather than the poor atttempt using degrees. 
#The resulting map is below - try to recreate it.

# transform St Pauls to BNG and buffer using 25 km
london_bng <- st_buffer(st_transform(st_pauls, 27700), 25000)
# In one line, transform england to BNG and cut out London
england_not_london_bng <- st_difference(st_transform(st_sfc(england, crs=4326), 27700), london_bng)
# project the other features and combine everything together
others_bng <- st_transform(st_sfc(eire, northern_ireland, scotland, wales, crs=4326), 27700)
corrected <- c(others_bng, london_bng, england_not_london_bng)
# Plot that and marvel at the nice circular feature around London
par(mar=c(3,3,1,1))
plot(corrected, main='25km radius London', axes=TRUE)


####4.Rasters####

#Rasters are the other major type of spatial data.
#They consist of a regular grid in space, defined 
#by a coordinate system, an origin point, a 
#resolution and a number of rows and columns. 
#They effectively hold a matrix of data. We will 
#use the raster package to handle raster data.

# Create an empty raster object covering UK and Eire
uk_raster_WGS84 <- raster(xmn=-11,  xmx=2,  
                          ymn=49.5, ymx=59, 
                          res=0.5, 
                          crs="+init=EPSG:4326")
hasValues(uk_raster_WGS84)

# Add data to the raster: just the number 1 
#to number of cells
values(uk_raster_WGS84) <- seq(length(uk_raster_WGS84))
plot(st_geometry(uk_eire), add=TRUE, border='black', 
     lwd=2, col='#FFFFFF44')

#Changing the raster resolution

# Define a simple 4 x 4 square raster
m <- matrix(c(1, 1, 3, 3,
              1, 2, 4, 3,
              5, 5, 7, 8,
              6, 6, 7, 7), ncol=4, byrow=TRUE)
square <- raster(m)

#Aggregating rasters
#With aggregating, we choose an aggregation factor
#- how many cells to group - and then lump sets of cells 
#together. So, for example, a factor of 2 will aggregate 
#blocks of 2x2 cells.
# Average values
square_agg_mean <- aggregate(square, fact=2, fun=mean)
values(square_agg_mean)
plot(square_agg_mean)

# Maximum values
square_agg_max <- aggregate(square, fact=2, fun=max)
values(square_agg_max)
plot(square_agg_max)

# Modal values for categories
#if the raster values represent categories (like land cover), 
#then mean doesn’t make sense at all: the average of Forest 
#(2) and Moorland (3) is easy to calculate but what does it 
#actually mean!
# La moda!!!
square_agg_modal <- aggregate(square, fact=2, fun=modal)
values(square_agg_modal)
#note that ## The bottom left cell has a modal value 
#of 6 even though there is no mode: there are two 5s and two
#6s. You can use `first` and `last` to specify which value 
#gets chose but there is no mode.

###Disagregating Rastersx 
# Copy parents
square_disagg <- disaggregate(square, fact=sqrt(16),
                              method = '')
plot(square_disagg)
# Interpolate
square_disagg_interp <- disaggregate(square, fact=sqrt(16), 
                                     method='bilinear')
plot(square_disagg_interp)
###4.3 Reprojecting a raster###

#In the example here, we are show how our 0.5° WGS84 raster 
#for the UK and Eire (grey) compares to a 100km resolution 
#raster on the British National Grid (red).

# make two simple `sfc` objects containing points in  the
# lower left and top right of the two grids
uk_pts_WGS84 <- st_sfc(st_point(c(-11, 49.5)), 
                       st_point(c(2, 59)), crs=4326)
uk_pts_BNG <- st_sfc(st_point(c(-2e5, 0)), 
                     st_point(c(7e5, 1e6)), crs=27700)

#  Use st_make_grid to quickly create a polygon grid with the right cellsize
uk_grid_WGS84 <- st_make_grid(uk_pts_WGS84, cellsize=0.5)
uk_grid_BNG <- st_make_grid(uk_pts_BNG, cellsize=1e5)

# Reproject BNG grid into WGS84
uk_grid_BNG_as_WGS84 <- st_transform(uk_grid_BNG, 4326)

# Plot the features
plot(uk_grid_WGS84, asp=1, border='grey', xlim=c(-13,4))
plot(st_geometry(uk_eire), add=TRUE, border='darkgreen', 
     lwd=2)
plot(uk_grid_BNG_as_WGS84, border='red', add=TRUE)

#Lets reproject!!
#We will use the projectRaster function, which gives us the 
#choice of interpolating a representative value from the 
#source data (method='bilinear') or picking the cell value f
#rom the nearest neighbour to the new cell centre 
#(method='ngb'). We first create the target raster - we don’t 
#have to put any data into it - and use that as a template 
#for the reprojected data.
# Create the target raster
uk_raster_BNG <- raster(xmn=-200000, xmx=700000, ymn=0, 
                        ymx=1000000,res=100000, 
                        crs='+init=EPSG:27700')
#What the hell are we doing here?
#Take the grey grid, and reproyecting it into the red grid, using 2 techniques: bilinear and ngb
#bilinear uses a weighted average of the fourest nearest cell centers - not recommended for 
#categorical data#
#nearest neighbor aka ngb is best used for categorical data, value of the output cell is determined 
#by the nearest cell center on the input grid#

uk_raster_BNG_interp <- projectRaster(uk_raster_WGS84, uk_raster_BNG, method='bilinear')
uk_raster_BNG_ngb <- projectRaster(uk_raster_WGS84, uk_raster_BNG, method='ngb')
# compare the values in the top row
round(values(uk_raster_BNG_interp)[1:9], 2)
values(uk_raster_BNG_ngb)[1:9]

#Note that for the cells in the top right and left, 
#projectRaster has assigned an NA value. In the plot above, 
#you can see that the centres of those red cells do not 
#overlie the original grey grid. If we plot the two outputs 
#you can see the more abrupt changes when using nearest 
#neighbour reprojection.
par(mfrow=c(1,3), mar=c(1,1,2,1))
plot(uk_raster_BNG_interp, main='Interpolated', axes=FALSE, legend=FALSE)
plot(uk_raster_BNG_ngb, main='Nearest Neighbour',axes=FALSE, legend=FALSE)

####5 Converting between vector and raster data types####

###5.1 Vector to raster###

#One problem here is that raster predates sf and 
#wants the vector data in the older Spatial data type 
#from the sp package. Fortunately, that is easy to 
#convert: as(sf_object, 'Spatial') does the trick.

# Create the target raster 
uk_20km <- raster(xmn=-200000, xmx=650000, ymn=0, 
                  ymx=1000000, res=20000, 
                  crs='+init=EPSG:27700')
#Rasterizing polygons
uk_eire_poly_20km  <- rasterize(as(uk_eire_BNG, 
                                   'Spatial'), 
                                uk_20km, field='name')
# Rasterizing polygons
uk_eire_poly_20km  <- rasterize(as(uk_eire_BNG, 
                                   'Spatial'), 
                                uk_20km, field='name')

# Rasterizing lines
uk_eire_BNG_line <- st_cast(uk_eire_BNG, 'LINESTRING')

#Here, we are being warned that the country 
#attributes might not apply to the lines. We can use 
#the st_agr function to tell sf that attributes are 
#constant and it will stop warning us.
st_agr(uk_eire_BNG) <- 'constant'

# Rasterizing lines
uk_eire_BNG_line <- st_cast(uk_eire_BNG, 'LINESTRING')
uk_eire_line_20km <- rasterize(as(uk_eire_BNG_line, 'Spatial'), uk_20km, field='name')

# Rasterizing points 
# - This isn't quite as neat. You need to take two steps in the cast and need to convert 
#   the name factor to numeric.
uk_eire_BNG_point <- st_cast(st_cast(uk_eire_BNG, 'MULTIPOINT'), 'POINT')
uk_eire_BNG_point$name <- as.numeric(uk_eire_BNG_point$name)
uk_eire_point_20km <- rasterize(as(uk_eire_BNG_point, 'Spatial'), uk_20km, field='name')

# Plotting those different outcomes
par(mfrow=c(1,3), mar=c(1,1,1,1))
plot(uk_eire_poly_20km, col=viridis(6, alpha=0.5), legend=FALSE, axes=FALSE)
plot(st_geometry(uk_eire_BNG), add=TRUE, border='grey')

plot(uk_eire_line_20km, col=viridis(6, alpha=0.5), legend=FALSE, axes=FALSE)
plot(st_geometry(uk_eire_BNG), add=TRUE, border='grey')

plot(uk_eire_point_20km, col=viridis(6, alpha=0.5), legend=FALSE, axes=FALSE)
plot(st_geometry(uk_eire_BNG), add=TRUE, border='grey')


###5.2 Raster to Vector###

# rasterToPolygons returns a polygon for each cell and returns a Spatial object
poly_from_rast <- rasterToPolygons(uk_eire_poly_20km)
poly_from_rast <- as(poly_from_rast, 'sf')

# but can be set to dissolve the boundaries between cells with identical values
#This crashes my R!!
poly_from_rast_dissolve <- rasterToPolygons(uk_eire_poly_20km, dissolve=TRUE)
poly_from_rast_dissolve <- as(poly_from_rast_dissolve, 'sf')

# rasterToPoints returns a matrix of coordinates and values.
points_from_rast <- rasterToPoints(uk_eire_poly_20km)
points_from_rast <- st_as_sf(data.frame(points_from_rast), coords=c('x','y'))
# Plot the outputs - using key.pos=NULL to suppress the key and
# reset=FALSE to avoid plot.sf altering the par() options


par(mfrow=c(1,3), mar=c(1,1,1,1))
plot(poly_from_rast['layer'], key.pos = NULL, reset = FALSE)
plot(poly_from_rast_dissolve, key.pos = NULL, reset = FALSE)
plot(points_from_rast, key.pos = NULL, reset = FALSE)

####6 Using data in files####


###6.1 Saving vector data###

st_write(uk_eire, '../Data/uk_eire_WGS84.shp')
st_write(uk_eire_BNG, '../Data/uk_eire_BNG.shp')


#Other formats of writing GIS data
st_write(uk_eire, '../Data/uk_eire_WGS84.geojson')
st_write(uk_eire, '../Data/uk_eire_WGS84.gpkg')

#The sf package will try and choose the output format based on the file suffix 
#(so .shp gives ESRI Shapefile). If you don’t want to use the standard file 
#suffix, you can also specify a driver directly: a driver is simply a bit of 
#internal software that reads or writes a particular format and you can see the 
#list of available formats using st_drivers()
st_write(uk_eire, '../Data/uk_eire_WGS84.json', driver='GeoJSON')


###6.2 Saving raster data###

#The GeoTIFF file format is one of the most common GIS 
#raster data formats. It is basically the same as a TIFF 
#image file but contains embedded data describing the origin,
#resolution and coordinate reference system of the data
# Save a GeoTiff
writeRaster(uk_raster_BNG_interp, '../Data/uk_raster_BNG_interp.tiff',
            overwrite = T, formats = '.tif')
# Save an ASCII format file: human readable text. 
# Note that this format does not contain the projection details!
writeRaster(uk_raster_BNG_ngb, '../Data/uk_raster_BNG_ngb.asc', format='ascii',
            overwrite = T)


###6.3 Loading Vector data###

# Load a vector shapefile
ne_110 <- st_read('../Data/ne_110m_admin_0_countries/ne_110m_admin_0_countries.shp')

life_exp <- read.csv(file = "../Data/WHOSIS_000001.csv")

#Using the data loaded above, recreate the two plots 
#shown below of global GDP and 2016 global life 
#expectancy, averaged for both sexes. This only needs
#the plotting and merging skills from above.

#The GDP data is already in the ne_110 data, but you 
#will need to add the life expectancy data to the GIS
#data. Getting country names to match between datasets 
#is unexpectedly a common problem: try using the 
#ISO_A3_EH field in ne_110. The other gotcha with 
#merge is that, by default, the merge drops rows 
#when there is no match. Here, it makes sense to use
#all.x=TRUE to retain all the countries: they will 
#get NA values for the missing life expectancy.

#The life expectancy plot has been altered to show 
#less blocky colours in a nicer palette (viridis). 
#You will need to set the breaks and pal arguments to 
#get this effect.
# Generate two stacked plots with narrow margins
par(mfrow=c(2,1), mar=c(1,1,1,1))

# The first plot is easy
plot(ne_110['GDP_MD_EST'],  asp=1, main='Global GDP', logz=TRUE, key.pos=4)

#Thend for the second we need to merge the data
ne_110 <- merge(ne_110, life_exp, by.x='ISO_A3_EH', by.y='COUNTRY', all.x=TRUE)
# Create a sequence of break values to use for display
bks <- seq(50, 85, by=5)
# Plot the data
plot(ne_110['Numeric'], asp=1, main='Global 2016 Life Expectancy (Both sexes)',
     breaks=bks, pal=viridis, key.pos=4)

## Loading XY data
#One common source of vector data is a table with 
#coordinates in it (either longitude and latitude for 
#geographic coordinates or X and Y coordinates for a 
#projected coordinate system). We will load some data like 
#this and convert it into a proper sf object. You do have 
#to know the coordinate system!
# Read in Southern Ocean example data
so_data <- read.csv('../Data/Southern_Ocean.csv', header=TRUE)
head(so_data)
so_data <- st_as_sf(so_data, coords=c('long', 'lat'), crs=4326)
head(so_data)
###6.4 Loading Raster data###

etopo_25 <- raster('../Data/etopo_25.tif')
print(etopo_25)
plot(etopo_25)

###Task:  Controlling raster plots###
#That isn’t a particularly useful colour 
#scheme. Can you work out how to create 
#the plot below? Some hints: you’ll need 
#to set breaks again and then provide two 
#colour palettes that match the values 
#either side of 0. The function colorRampPal
#ette is really helpful here, or you could 
#use the built-in palettes.

#You will also need to set the values that 
#get labelled and their labels and this 
#isn’t obvious. It needs to be set in the 
#plot command like this:
bks = c(seq(-10000, -250, by = 250), seq(0, 6000, by=250))
colors1 = colorRampPalette(c('darkblue', 'lightblue'))(length(seq(-10000,-250, by = 250)))
colors2 = colorRampPalette(c('darkgreen', 'yellow', 'orange','brown'))(length(seq(0,6000, by = 250)))
plot(etopo_25, col = c(colors1, colors2), 
     breaks = bks, axes = F, 
     axis.args = list(at=seq(-10000, 6000, by=2000), lab = seq(-10, 6, by = 2)))


##6.4.1 Raster Stacks##

tmax <- getData('worldclim', download=TRUE, path='../Data', var='tmax', res=10)
print(tmax)

# scale the data
tmax <- tmax / 10
# Extract  January and July data and the annual maximum by location.
tmax_jan <- tmax[[1]]
tmax_jul <- tmax[[7]]
tmax_max <- max(tmax)
# Plot those maps
par(mfrow=c(3,1), mar=c(2,2,1,1))
bks <- seq(-500, 500, length=101)
pal <- colorRampPalette(c('lightblue','grey', 'firebrick'))
cols <- pal(100)
ax.args <- list(at= seq(-500, 500, by=100))
plot(tmax_jan, col=cols, breaks=bks, axis.args=ax.args, main='January maximum temperature')
plot(tmax_jul, col=cols, breaks=bks, axis.args=ax.args, main='July maximum temperature')
plot(tmax_max, col=cols, breaks=bks, , axis.args=ax.args, main='Annual maximum temperature')


####7 Overlaying raster and vector data####

###7.1 Cropping data###
so_extent <- extent(-60, -20, -65, -45)
# The crop function for raster data...
so_topo <- crop(etopo_25, so_extent)
ne_10 <- st_read('../Data/ne_10m_admin_0_countries/ne_10m_admin_0_countries.shp')
st_agr(ne_10) <- 'constant'
so_ne_10 <- st_crop(ne_10, so_extent)
## although coordinates are longitude/latitude,
#st_intersection assumes that they are planar
plot(so_topo)

sea_pal <- colorRampPalette(c('grey30', 'grey50', 'grey70'))
plot(so_topo, col=sea_pal(100), asp=1, legend=FALSE)
contour(so_topo, levels=c(-2000, -4000, -6000), add=TRUE, col='grey80')
plot(st_geometry(so_ne_10), add=TRUE, col='grey90', border='grey40')
plot(so_data['chlorophyll'], add=TRUE, logz=TRUE, pch=20, cex=2, pal=viridis, border='white', reset=FALSE)
.image_scale(log10(so_data$chlorophyll), col=viridis(18), key.length=0.8, key.pos=4, logz=TRUE)


####8 Spatial joins and raster data extraction####

###8.1 Spatial joining###
# extract Africa from the ne_110 data and keep the columns we want to use
africa <- subset(ne_110, CONTINENT=='Africa', select=c('ADMIN', 'POP_EST'))

# transform to the Robinson projection
africa <- st_transform(africa, crs=54030)
# create a random sample of points
mosquito_points <- st_sample(africa, 1000)

# Create the plot
plot(st_geometry(africa), col='khaki')
plot(mosquito_points, col='firebrick', add=TRUE)

mosquito_points <- st_sf(mosquito_points)
mosquito_points <- st_join(mosquito_points, africa['ADMIN'])

plot(st_geometry(africa), col='khaki')
plot(mosquito_points['ADMIN'], add=TRUE)

#We can now aggregate the points within
#countries. This can give us a count of the 
#number of points in each country and also 
#converts multiple rows of POINT into a single 
#MULTIPOINT feature per country.
mosquito_points_agg <- aggregate(mosquito_points, by=list(country=mosquito_points$ADMIN), FUN=length)
names(mosquito_points_agg)[2] <-'n_outbreaks'
head(mosquito_points_agg)
plot(mosquito_points_agg, add = T)

africa <- st_join(africa, mosquito_points_agg)
africa$area <- as.numeric(st_area(africa))
head(africa)


par(mfrow=c(1,2), mar=c(3,3,1,1), mgp=c(2,1, 0))
plot(n_outbreaks ~ POP_EST, data=africa, log='xy', 
     ylab='Number of outbreaks', xlab='Population size')
plot(n_outbreaks ~ area, data=africa, log='xy',
     ylab='Number of outbreaks', xlab='Area (m2)')

#Task: alien invasion#

# Load the data and convert to a sf object
alien_xy <- read.csv('../Data/aliens.csv')
alien_xy <- st_as_sf(alien_xy, coords=c('long','lat'), crs=4326)

# Add country information and find the total number of aliens per country
#Matchjing it by 'geometry
alien_xy <- st_join(alien_xy, ne_110['ADMIN'])
aliens_by_country <- aggregate(n_aliens ~ ADMIN, data=alien_xy, FUN=sum)

# Add the alien counts into the country data 
ne_110 <- merge(ne_110, aliens_by_country, all.x=TRUE)
ne_110$aliens_per_capita <- with(ne_110,  n_aliens / POP_EST)

# create the scale colours
bks <- seq(-8, 2, length=101)
pal <- colorRampPalette(c('darkblue','lightblue', 'salmon','darkred'))

plot(ne_110['aliens_per_capita'], logz=TRUE, breaks=bks, pal=pal, key.pos=4)


###8.2 Extracting data from Rasters###
uk_eire_etopo <- raster('../Data/etopo_uk.tif')

uk_eire_detail <- subset(ne_10, ADMIN %in% c('United Kingdom', "Ireland"))
uk_eire_detail_raster <- rasterize(as(uk_eire_detail, 'Spatial'), uk_eire_etopo)
uk_eire_elev <- mask(uk_eire_etopo, uk_eire_detail_raster)

par(mfrow=c(1,2), mar=c(3,3,1,1), mgp=c(2,1,0))
plot(uk_eire_etopo, axis.args=list(las=3))
plot(uk_eire_elev, axis.args=list(las=3))
plot(st_geometry(uk_eire_detail), add=TRUE, border='grey')


##8.2.1 Raster cell statistics and locations##
cellStats(uk_eire_elev, max)
cellStats(uk_eire_elev, quantile)
which.max(uk_eire_elev)
Which(uk_eire_elev > 1100, cells=TRUE)


max_cell <- which.max(uk_eire_elev)
max_xy <- xyFromCell(uk_eire_elev, max_cell)
max_sfc<- st_sfc(st_point(max_xy), crs=4326)
bsl_cell <- Which(uk_eire_elev < 0, cells=TRUE)
bsl_xy <- xyFromCell(uk_eire_elev, bsl_cell)
bsl_sfc <- st_sfc(st_multipoint(bsl_xy), crs=4326)

#Plot the locations of the maximum altitude 
#and cells below sea level on the map. 
#Some questions about the result:
plot(uk_eire_elev, axis.args=list(las=3))
plot(max_sfc, add=TRUE, pch=24, bg='red')
plot(bsl_sfc, add=TRUE, pch=25, bg='lightblue', cex=0.6)


##8.2.2The extract funciot##
uk_eire_capitals$elev <- extract(uk_eire_elev, uk_eire_capitals)
print(uk_eire_capitals)

uk_eire$mean_height <- extract(uk_eire_elev, uk_eire, fun=mean, na.rm=TRUE)
uk_eire

st_layers('../Data/National_Trails_Pennine_Way.gpx')
pennine_way <- st_read('../Data/National_Trails_Pennine_Way.gpx', layer='routes', 
                       query="select * from routes where name='Pennine Way'")


#Task
# reproject the vector data
pennine_way_BNG <- st_transform(pennine_way, crs=27700)
# create the target raster and project the elevation data into it.
bng_1km <- raster(xmn=-200000, xmx=700000, ymn=0, ymx=1000000, 
                  res=1000, crs='+init=EPSG:27700')
uk_eire_elev_BNG <- projectRaster(uk_eire_elev, bng_1km)



# Simplify the data
pennine_way_BNG_simple <- st_simplify(pennine_way_BNG,  dTolerance=100)

# Zoom in to the whole route and plot the data
par(mfrow=c(1,2), mar=c(1,1,1,1))

plot(uk_eire_elev_BNG, xlim=c(3e5, 5e5), ylim=c(3.8e5, 6.3e5),
     axes=FALSE, legend=FALSE)
plot(st_geometry(pennine_way_BNG), add=TRUE, col='black')
plot(pennine_way_BNG_simple, add=TRUE, col='darkred')
## Warning in plot.sf(pennine_way_BNG_simple, add = TRUE, col = "darkred"):
## ignoring all but the first attribute

# Add a zoom box and use that to create a new plot
zoom <- extent(3.77e5, 3.89e5, 4.7e5, 4.85e5)
plot(zoom, add=TRUE)

# Zoomed in plot
plot(uk_eire_elev_BNG, ext=zoom, axes=FALSE, legend=FALSE)
plot(st_geometry(pennine_way_BNG), add=TRUE, col='black')
plot(pennine_way_BNG_simple, add=TRUE, col='darkred')
## Warning in plot.sf(pennine_way_BNG_simple, add = TRUE, col = "darkred"):
## ignoring all but the first attribute


# Extract the data
pennine_way_trans <- extract(uk_eire_elev_BNG, pennine_way_BNG_simple, 
                             along=TRUE, cellnumbers=TRUE)

# The output is a list: in will contain one set of values for each feature in the input data
str(pennine_way_trans)

# Here, we only have one line, so we will extract it
pennine_way_trans <- pennine_way_trans[[1]]
pennine_way_trans <- data.frame(pennine_way_trans)

# Get the cell coordinates 
pennine_way_xy <- xyFromCell(uk_eire_elev_BNG, pennine_way_trans$cell)
pennine_way_trans <- cbind(pennine_way_trans, pennine_way_xy)

# Now we can use Pythagoras to find the distance along the transect
pennine_way_trans$dx <- c(0, diff(pennine_way_trans$x))
pennine_way_trans$dy <- c(0, diff(pennine_way_trans$y))
pennine_way_trans$distance_from_last <- with(pennine_way_trans, sqrt(dx^2 + dy^2))
pennine_way_trans$distance <- cumsum(pennine_way_trans$distance_from_last)

plot( etopo_uk ~ distance, data=pennine_way_trans, type='l', 
      ylab='Elevation (m)', xlab='Distance (m)')




**********************************************************************

Testing GIS.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Error in setwd("Desktop/Imperial/CMEECourseWork/Week5/Code/") : 
  cannot change working directory
Execution halted

======================================================================
Inspecting script file research_taste.R...

File contents are:
**********************************************************************
setwd('/Users/pablolechon/Desktop/Imperial/CMEECourseWork/Week5/Code/')
rm(list = ls())
library(plyr)

d = read.csv('../Data/dessert.txt')


#With DM
ddm = subset(d, d$species=='DM')
ddmf = subset(ddm, ddm$sex == 'F')
ddmm = subset(ddm, ddm$sex == 'M')

#Removing repeated values
ddmf = dplyr::distinct(ddmf, tag = ddmf$tag, .keep_all = T)
ddmm = dplyr::distinct(ddmm, tag = ddmm$tag, .keep_all = T)

#Rewriting months
#ddmf
for (i in seq(length(ddmf$mo))){
  if (nchar(as.character(ddmf$mo[i])) == 1){
    ddmf$mo[i] = paste(0,ddmf$mo[i], sep = '')
  }
  else{
    ddmf$mo[i] = as.character(ddmf$mo[i])
  }
}

#ddmm
#ddmf
for (i in seq(length(ddmm$mo))){
  if (nchar(as.character(ddmm$mo[i])) == 1){
    ddmm$mo[i] = paste(0,ddmm$mo[i], sep = '')
  }
  else{
    ddmm$mo[i] = as.character(ddmm$mo[i])
  }
}

#Calculating the mean per month
ddmf$date = paste(ddmf$yr, ddmf$mo, sep = '')
ddmm$date = paste(ddmm$yr, ddmf$mo, sep = '')

#Converting date column to a number
ddmf$date = sapply(ddmf$date,  as.numeric)
ddmm$date = sapply(ddmm$date,  as.numeric)

dplyr::tbl_df(ddmf);dplyr::tbl_df(ddmm)



table_ddmf = ddply(ddmf, .(date), summarize,
      mean_wgt = mean(wgt, na.rm = T),
      mean_precip = mean(precip, na.rm = T))

table_ddmm = ddply(ddmm, .(date), summarize,
                   mean_wgt = mean(wgt, na.rm = T),
                   mean_precip = mean(precip, na.rm = T))
#Plots
plot(seq(length(table_ddmf$mean_precip)), table_ddmf$mean_precip,
     type = 'l',lty = 1, col = 'blue', 
     xlab = 'Time')
lines(seq(length(table_ddmf$mean_precip)), table_ddmf$mean_wgt, 
      type = 'l',lty = 1, col = 'red', yaxt='n', ann=FALSE)
**********************************************************************

Testing research_taste.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Error in setwd("/Users/pablolechon/Desktop/Imperial/CMEECourseWork/Week5/Code/") : 
  cannot change working directory
Execution halted

======================================================================
======================================================================
Finished running scripts

Ran into 3 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 100

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!